syntax = "proto3";

package mandoline.protobuf;

// A vector or position in R^2
message Vec2d {
    double x = 1;
    double y = 2;
}
// A vector or position in R^3
message Vec3d {
    double x = 1;
    double y = 2;
    double z = 3;
}


// An integer vector in Z^2, also may be an edge
message Vec2i {
    int64 x = 1;
    int64 y = 2;
}
// An integer vector in Z^3, also may be a triangle
message Vec3i {
    int64 x = 1;
    int64 y = 2;
    int64 z = 3;
}

// An axis aligned plane, defined implicitly by {[x_1,x_2,x_3]: x_axis == value} 
message AxialPlane {
    int64 axis = 1;
    int64 value = 2;
}



// The indices of the vertices of a polygon defined by a single boundary loop
message BoundaryLoop {
    repeated int64 indices = 1;
}

// Our cut-cell mesh lies in a stencil of grid cells.  Outside of that stencil
// we maintain an "adaptive grid" that represents cells via a different
// mechanism.  To connect our cut-faces on the boundary of the stencil we store
// which regular grid cell this is adjacent to as well as the relative sign
// between the cut-face and grid cell
message StencilBoundary {
    int64 index = 1;
    bool sign = 2;
}

message CutEdge {
    // The boundary loops for the polygon
    Vec2i indices = 1;
    // the parent geometory that this is cut from
    oneof id {
        int64 edge_id = 3;
        AxialPlane plane_id = 4; // this can only be set in a 2D mesh
        AxialEdge3 _id = 5; // this can only be set in a 3D mesh
    }

}


// lists off the boundaries in terms of staggered-grid edge indices
message ExteriorGrid {
    // Adaptive grid structure stuff
    // each is these is represented by a staggered-grid index and a width
    map<int64,Vec2i> cells = 1;
    map<int64,Vec2i> faces = 2;
    map<int64,Vec2i> edges = 3;

    map<int64,Vec2i> cell_boundary = 4;
    map<int64,Vec2i> face_boundary = 5;

    // the region ids for the cube-cells, they're aligned with the regions used for cut-cells
    map<int64,int64> square_regions = 14;

    bool adaptive = 2;
}

